This is a course note for C++ Algorithm, Data structure udemy course

TYPE OF DATA STRUCTURES

Physical; how the memory should be organized
1. Array; size is static, can be created in stack, heap
2. Linked list; linked to next node, has variable length, created in heap

Logical; are implemented using physical data structure

linear
1. stack
2. queues
non-linear
3. tress 
4. graph
tabular
5. hash table
 
 ABSTRACT DATATYPE (ADT)
 1. representation of data
 2. operation on data

RECURSION //function calling itself
void fun1(int n)
{
    if(n>0)
    {
        fun1(n-1;)
        print("%d",n); //the output is 1,2,3. 
                       //Every function call rturns to its calling point
        
    }
}
void main()
{
    int x=3;
    fun1(x); 
}

TIME COMPLEXITY IN RECURSIVE FUNCTION
print n units
= O(n)

void fun1(int n) //T(n)
{
    if(n>0) //1
    {
        print("%d",n); //1
        fun1(n-1;) //T(n-1)
    }
}
so T(n) = 1(n=0), T(n-1)+2(n>0)
= T(n-k)+k

assume n-k=0, n=k
T(n) = 1 + n


TYPES OF RECURSION
1. Tail Recursion
void fun(int n)
{
    if(n>0)
    {
        -----
        -----
        fun(n-1); //finish things and call itself
    }
}
void fun(int n)
{
    while(n>0) //loop tail recursion
    {
        cout(n);
        n--
    }
}
Comparison: Running time is same
Space : O(n)
        O(1) //loop takes less space, more efficient
2. Head Recursion
void fun(int n)
{
    if(n>0)
    {
        fun(n-1); //call itself and execute following code
        -----
        -----
    }
}

void fun(int n) //loop version
{
    int i = 1;
    while(i<=n)
    {
        cout << i;
        i++;
        -----
        -----
    }
}
3. Tree Recursion //calling itself more than 1 time
fun(n) //calltime 2^(n+1) -1 = O(2^n), space = O(n)
{
    if(n>0)
    {
        ---
        fun(n-1);
        ---
        fun(n-1);
        ---
    }
}

Linear Recursion
fun(n)
{
    if(n>0)
    {
        ---
        fun(n-1); //calling only 1 time
        ---
    }
} 

4. Indirect Recursion
void funA(int n)
{
    if(n>0)
    {
        cout << n;
        funB(n-1);
    }
}
void funB(int n)
{
    if(n>1)
    {
        cout <<n;
        funA(n/2);
    }
}
5. Nested Recursion
int fun(int n)
{
    if(n>100)
    {
        return n-10;
    }
    else
    return fun(fun(n+11));
}